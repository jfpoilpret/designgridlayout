<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_05) on Sat Feb 14 21:05:26 ICT 2009 -->
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<TITLE>
net.java.dev.designgridlayout (DesignGridLayout 1.1 API)
</TITLE>

<META NAME="keywords" CONTENT="net.java.dev.designgridlayout package">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="net.java.dev.designgridlayout (DesignGridLayout 1.1 API)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../net/java/dev/designgridlayout/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV PACKAGE&nbsp;
&nbsp;NEXT PACKAGE</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/java/dev/designgridlayout/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package net.java.dev.designgridlayout
</H2>
<code>DesignGridLayout</code> is a revolutionary <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/awt/LayoutManager.html" title="class or interface in java.awt"><CODE>LayoutManager</CODE></A> for
 Swing applications, based on "canonical grids", well-known in publishing.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Interface Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../net/java/dev/designgridlayout/IGridRow.html" title="interface in net.java.dev.designgridlayout">IGridRow</A></B></TD>
<TD>Any row created by <code>DesignGridLayout.row().grid()</code> implements this
 interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../net/java/dev/designgridlayout/INonGridRow.html" title="interface in net.java.dev.designgridlayout">INonGridRow</A></B></TD>
<TD>Any row created by one of <code>DesignGridLayout.row().left()</code>, 
 <code>DesignGridLayout.row().center()</code> or <code>DesignGridLayout.row().right()</code> 
 implements this interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../net/java/dev/designgridlayout/IRow.html" title="interface in net.java.dev.designgridlayout">IRow</A></B></TD>
<TD>Any row created by <A HREF="../../../../net/java/dev/designgridlayout/DesignGridLayout.html" title="class in net.java.dev.designgridlayout"><CODE>DesignGridLayout</CODE></A> implements this minimal
 interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../net/java/dev/designgridlayout/IRowCreator.html" title="interface in net.java.dev.designgridlayout">IRowCreator</A></B></TD>
<TD>Interface returned by <A HREF="../../../../net/java/dev/designgridlayout/DesignGridLayout.html#row()"><CODE>DesignGridLayout.row()</CODE></A> in order to specify the
 type of row to be actually added to the current layout (grid, centered, left-
 or right-aligned).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../net/java/dev/designgridlayout/ISpannableGridRow.html" title="interface in net.java.dev.designgridlayout">ISpannableGridRow</A></B></TD>
<TD>Rows created by <code>DesignGridLayout.row().grid()</code> and 
 <code>DesignGridLayout.row().grid(JLabel)</code> implement this interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../net/java/dev/designgridlayout/ISubGridStarter.html" title="interface in net.java.dev.designgridlayout">ISubGridStarter</A></B></TD>
<TD>This interface is used to start a new canonical grid row (when called from
 <A HREF="../../../../net/java/dev/designgridlayout/DesignGridLayout.html#row()"><CODE>DesignGridLayout.row()</CODE></A>), or to start a new canonical sub-grid in the
 current grid row (when called from <A HREF="../../../../net/java/dev/designgridlayout/IGridRow.html" title="interface in net.java.dev.designgridlayout"><CODE>IGridRow</CODE></A>).</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../net/java/dev/designgridlayout/DesignGridLayout.html" title="class in net.java.dev.designgridlayout">DesignGridLayout</A></B></TD>
<TD>Swing LayoutManager that implements "Canonical Grids" as used by graphic 
 artists to design magazines, posters, forms...</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package net.java.dev.designgridlayout Description
</H2>

<P>
<code>DesignGridLayout</code> is a revolutionary <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/awt/LayoutManager.html" title="class or interface in java.awt"><CODE>LayoutManager</CODE></A> for
 Swing applications, based on "canonical grids", well-known in publishing.
 <p/>
 DesignGridLayout allows to define dialogs that are always visually balanced, 
 without ever needing any graphical designer, thanks to its fluent and 
 easy-to-use API, which enables you to literally "visualize" the layout in the 
 code itself.
 <p/>
 Using DesignGridLayout is straightforward:
 <pre>
 public class MyPanel extends JPanel {
     public MyPanel() {
         DesignGridLayout layout = new DesignGridLayout(this);
         
         layout.row().grid(labelA).add(fieldA);
         layout.row().grid(labelB).add(fieldB);
         //...
         layout.row().center().add(okButton, cancelButton);
     }
     
     private JLabel labelA = new JLabel("aaa");
     private JTextField fieldA = new JTextField();
     private JLabel labelB = new JLabel("bbb");
     private JTextField fieldB = new JTextField();
     //...
     private JButton okButton = new JButton("OK");
     private JButton cancelButton = new JButton("Cancel");
 }
 </pre>
 As you can see in this example, each row of components in the panel can be 
 set through one single line of source code. Each component is added from left 
 to right.
 <p/>
 Labels (when created with 
 <A HREF="../../../../net/java/dev/designgridlayout/ISubGridStarter.html#grid(javax.swing.JLabel)"><CODE>grid(javax.swing.JLabel)</CODE></A>)
 have a special treatment: they are automatically right-aligned and the 
 label column in the panel has constant width.
 <p/>
 All gaps between components and between components and panel borders are
 automatically calculated by DesignGridLayout according to the current 
 installed LookAndFeel: no need to hardcode anything!
 <p/>
 DesignGridLayout offers 5 types of rows:
 <ul>
  <li>Grid Row: all components added to this kind of row are visually balanced
        according to other grid rows, and follow best practices applied in
        publishing on how to split the panel among "columns" of components</li>
  <li>Center Row: all components in this row are centered, they are never sized
        bigger than their preferred size (except when <code>fill()</code> is
        used (see below))</li>
  <li>Left Row: all components in this row are aligned on the left, they are
        never sized bigger than their preferred size (except when <code>fill()</code> 
        is used (see below))</li>
  <li>Right Row: all components in this row are aligned on the right, they are
        never sized bigger than their preferred size (except when <code>fill()</code>
        is used (see below))</li>
  <li>Empty Row: this row has no component but has a fixed height (automatically
        calculated to "visually separate" two groups of components). This is 
        useful when you want to add some space between groups of rows.</li>
 </ul>
 Center, Left and Right Rows have a special "fill" option that allows their 
 extreme component(s) (rightmost component for a Left Row, leftmost component 
 for a Right Row, and both leftmost and rightmost components for a Center Row) 
 fill all the extra space. This can be useful for instance when you want to 
 visually separate groups of rows:
 <pre>
     layout.row().left().fill().add(new JLabel("Group"), new JSeparator());
 </pre>
 <p/>
 DesignGridLayout allows you to add empty rows with a height that is 
 automatically calculated (depending on the current installed Look &amp; Feel),
 in order to introduce some space in your layout (e.g. to separate different 
 groups of logically releated items:
 <pre>
     layout.row().grid().add(...);
     layout.emptyRow();
     layout.row().right().add(new JButton("OK"), new JButton("Cancel"));
 </pre>
 In grid rows (added by calling <code>DesignGridLayout.row().grid()</code>), you 
 may specify that a given component spans several columns, this way, you can 
 ensure that fields that require longer input occupy enough space to render 
 this input, compared with shorter fields):
 <pre>
     layout.row().grid().add(new JTextField(), new JTextField());
     layout.row().grid().add(new JTextField(), 2).add(new JTextField());
     layout.row().grid().add(new JTextField()).empty();
 </pre>
 In this snippet, the first row has two short text fields on two columns (one
 per field); the second row has one long text field (on two columns) and one 
 short text field (on one column).
 <p/>
 For any Grid Row, the number of columns is normally defined by the number of
 added components in the row, components being counted as many times as their
 associated span (when explicitly specified). Note however, that you can also
 introduce empty columns in such a row:
 <pre>
     layout.row().grid().empty().add(new JTextField()).empty(2);
 </pre>
 This code creates a row with four columns, but only the second contains a 
 real component.
 
 <h3>Forms with multiple label columns</h3>
 With DesignGridLayout, it is also possible to define layouts with several 
 label columns. 
 <p/>
 Each such label column actually defines a new canonical grid (called 
 <b>"sub-grid"</b>). In one grid row, you can indicate you want to start a new 
 sub-grid by calling one of the existing 
 <A HREF="../../../../net/java/dev/designgridlayout/ISubGridStarter.html#grid()"><CODE>grid()</CODE></A> methods, then
 all components added to this sub-grid (by one of the several 
 <A HREF="../../../../net/java/dev/designgridlayout/IGridRow.html" title="interface in net.java.dev.designgridlayout"><CODE>IGridRow#add()</CODE></A> methods) will 
 be part of the sub-grid:
 <pre>
     layout.row().grid(label1).add(field1, field2).grid(label3).add(field3, field4);
     layout.row().grid(label5).add(field5)        .grid()      .add(field6);
 </pre>
 In this snippet, there are two rows and two sub-grids; in the first sub-grid, 
 there are 3 components, <code>field1</code>, <code>field2</code>, <code>field5</code>, in
 addition to labels <code>label1</code> and <code>label5</code>; the second sub-grid
 contains 3 components, <code>field3</code>, <code>field4</code>, <code>field6</code>, and
 one label <code>label5</code>; note that the second sub-grid in the second row
 has no label.
 <p/>
 To handle multiple sub-grids, special processing occurs in DesignGridLayout:
 <ul>
 <li>first of all, find out the total number of sub-grids in the whole layout
 (this is defined by the maximum number of calls to <code>grid()</code> among all
 rows of the layout). Note that this calculus is a bit more complex because
 it also accounts for <code>gridspan</code>s specified when starting a sub-grid).</li>
 <li>for each sub-grid, the width of its label column is always fixed 
 (calculated based on the largest label in the column); the other components
 in the sub-grid are organized canonically. All canonical parts of all 
 sub-grids (thus excluding the fixed-width label column) get an equal part of
 the available width.</li>
 </ul>
 Each sub-grid can be assigned an explicit <code>gridspan</code> to specify that it
 will span several sub-grids of the other rows. If you don't specify any
 <code>gridspan</code> when starting a new sub-grid, then this sub-grid will 
 automatically span all space on its right unless another call to a 
 <code>grid()</code> method occurs in the same row:
 <pre>
     layout.row().grid(label1).add(field1, field2).grid(label3).add(field3);
     layout.row().grid(label4).add(field4);
 </pre>
 In this snippet, there are 2 rows and 2 sub-grids; the first sub-grid in the
 second row (<code>field4</code>) spans the whole width of the form. If you want 
 the same layout but don't want <code>field4</code> to span the second sub-grid, 
 then you can write:
 <pre>
     layout.row().grid(label1)   .add(field1, field2).grid(label3).add(field3);
     layout.row().grid(label4, 1).add(field4);
 </pre>
 If you want more details about this feature, you can look at the API 
 documentation for <A HREF="../../../../net/java/dev/designgridlayout/ISubGridStarter.html" title="interface in net.java.dev.designgridlayout"><CODE>ISubGridStarter</CODE></A>.
 
 <h3>Components spanning multiple grid rows</h3>
 DesignGridLayout also allows you to define components that span several rows.
 This feature is available only on grid-rows (i.e. rows created with 
 <code>layout.row().grid(...)</code>).
 The way to use it is quite straightforward, you define a first row as usual:
 <pre>
     layout.row().grid(label1).add(field1).add(list);
 </pre>
 Then on the <b>next</b> row, you specify which grid column will "share" the
 same component as the first row (that component will thus span row 2):
 <pre>
     layout.row().grid(label2).add(field2).spanRow();
 </pre>
 Please note the use of <code>spanRow()</code> (instead of <code>add(...)</code>) to
 specify that we want the matching component in the previous row to span this
 row.
 <p/>
 This feature is described in further details in the API documentation of
 <A HREF="../../../../net/java/dev/designgridlayout/ISpannableGridRow.html#spanRow()"><CODE>ISpannableGridRow.spanRow()</CODE></A>.
 <p/>
 There are some limitations in the use of <code>spanRow()</code> that, unfortunately,
 are not detectable at compile-time. When you mistakenly call <code>spanRow()</code>
 in an impossible layout situation, DesignGridLayout will not throw any
 Exception at run-time, but will replace your calls to <code>spanRow()</code> by
 a special marker component: a <b>"spanRow()"</b> label with red background 
 and a tooltip describing the problem further.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Jason Aaron Osgood, Jean-Francois Poilpret</DD>
<DT><B>See Also:</B><DD><A HREF="../../../../net/java/dev/designgridlayout/DesignGridLayout.html" title="class in net.java.dev.designgridlayout"><CODE>DesignGridLayout</CODE></A></DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../net/java/dev/designgridlayout/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV PACKAGE&nbsp;
&nbsp;NEXT PACKAGE</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?net/java/dev/designgridlayout/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
Copyright © 2005-2009. All Rights Reserved.
</BODY>
</HTML>
